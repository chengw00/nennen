!----------------------------------------------------------------------
!
! Copyright University Corporation for Atmospheric Research (UCAR) 2016
! Research Application Laboratory (RAL)
! National Center for Atmospheric Research (NCAR)
! All Rights Reserved
!
! CONTACTS: Luca Delle Monache,   lucadm@ucar.edu
!           Stefano Alessandrini, alessand@ucar.edu
!           Will Cheng,           chengw@ucar.edu 
!----------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
NOTE on the LICENSE AGREEMENT
Use of the analog code is governed by the License Agreement that you can find in this directory.  
Please review the License Agreement. If you do not agree to these terms and conditions as provided, 
you will not be permitted to use the Software. Please note that downloading, installing, using, 
or copying of the software by you or by a third party on your behalf indicates your agreement to 
be bound by all of the terms and conditions specified in the License Agreement.  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

This document contains:

(1) Introduction, description of directory structure, instructions to run the code
(2) Compilations with different compilers, different platforms with serial or parallel options
(3) Description of the input namelist
(4) Caveats

==================================================
(1) INTRODUCTION, DIRS STRUCTURE, RUN INSTRUCTIONS
==================================================
 
Hi There,

This README contains instructions on the basic steps to get you going with the analog code.

First, the directory structure:

- "code": here you find the source code, executable, and makefile;
- "input": it contains input data and necessary input files (analog_ini.txt and weight_ini.txt);
- "output": it contains the output generated by the analog code (ascii or netcdf);
- "lib": libraries configuration code;
- "setup": scripts to set things up;
- "verification_scripts": scripts to generate verification diagrams as rank histogram, 
  reliability and sharpness, dispersion, ROC skill score, Brier skill score, and binned 
  spread/skill plot (see README_ver.scripts.txt for info on how to run the scripts).  

OK then, to run the code for your project you should: 
- Create directories with the project name under "input" and "output"; 
- Add to input/"PROJECT NAME" the input data (an input namelist called analog_input.nml, and 
  either one file for the predictions and one for the observations, or a single file containing both); 
  for format (netcdf) examples have a look at the file input/crtc2/crtc.verif.20141031.2sta.cdf.
  NOTE: in the input netcdf a "missing_value" (or a "_FillValue") attribute needs to be defined, common to 
  each variable (for predictions and observations, otherwise the code will quit!); this value will be 
  used also in the output file;
- In the so-called "ATEC" file format (see namelist below), the dimensional variables (C-format order)
  and names are as follows

  variable(gen_date, lead_time, site) 
   * gen_date: YYYYMMDD
   * lead_time: forecast lead time in hours, e.g., 0, 1, 2, 3, etc
   * site: name of site, e.g., crtc_s01, crtc_s04, etc

  example of the "ATEC" file format can be found in input/atec4_oper/veri.150602.000000.cdf 
- In the so-called "non-ATEC" file format (see namelist below), the dimensional variables (C-format order)
  and names are as follows

  variable(Days, Lead\ times, Staz)
   * Days: day of forecast, e.g., 1, 2, 3, etc, no link to calendar YYYYMMDD
   * Lead\ times: forecast lead time (could be hours or minutes)
   * Staz: station number, e.g., 1, 2, 3, etc

  example of the "non-ATEC" file format can be found in input/crtc2/crtc.verif.20141031.2sta.cdf or input/ium/stationdata_ium_input.cdf

- Add to input/"PROJECT NAME" an input namelist called analog_input.nml (you can use copies from existing 
  projects as existing template). 
- Make the necessary changes to analog_input.nml to set input and output file names, parameters related 
  to the variable to be predicted, the analog predictors, and the analog code (see below explanation of 
  each entry of analog_input.nml);
- Add to input/"PROJECT NAME" an input file containing the weights of the analog predictors called 
  weight_ini.txt (you can use copies from existing projects as existing template; basic configuration 
  is with all weights set to 1).  
- Go to the directory "code"; 
- Link the files analog_input.nml and weight_ini.txt to their copies in input/"PROJECT NAME";
- Compile the code (see intsructions below for Yellowstone);
- Run "./main_analog";
- The output of you run is under /output/"PROJECT NAME";
- Run the scripts under "verification_scripts" to assess the performance of the analog code.

Have fun!


==================================================
(2) COMPILATION INSTRUCTIONS
================================================== 

- scripts to compile (modify the paths/environments for your
  machine)

     * compile_gnu_seq.csh :  gfortran sequential compile
       * need to add "module load gnu/5.1.0" inside compile script
         for NCAR CISL HPC systems
     * compile_gnu_par.csh :  gfortran parallel compile
       * need to add "module load gnu/5.1.0" inside compile script
         for NCAR CISL HPC systems
     * compile_ifort_seq.csh: ifort sequential compile
     * compile_ifort_par.csh: ifort parallel compile
     * compile_ifort_seq_yellowstone.csh: ifort sequential compile on CISL yellowstone

  Details in how to set the compilation environment are
  explained below.

- requirements:

     * GNU compiler 5.1 or higher
     * Intel compiler 14.0.3 or higher
     * NETCDF libraries from GNU or Intel compilation
      
-----------------------------------------------
COMPILATION STEPS ON YELLOWSTONE: ifort and MPI
-----------------------------------------------
1) Suggested shell: "tcsh"

2) Load in the environment the modules:
module load intel/16.0.0

To correctly load these modules it could be necessary to unload the hdf5 module, 
by typing these commands:

module load intel/16.0.0
module unload hdf5

3) setenv NETCDF_ROOT /glade/apps/opt/netcdf/4.3.3.1/intel/16.0.0

4) setenv CODE $PATH/anen

5) setenv MPI_TOP /glade/u/home/chengw/intel/mpich2

   here you have to create your own mpich2 environment by linking the paths

   in /glade/u/home/chengw/intel/mpich2

      include -> /opt/ibmhpc/pe1307/mpich2/intel/include64
      lib -> /opt/ibmhpc/pe1307/mpich2/intel/lib64
      bin/mpif90 -> /glade/apps/opt/modulefiles/ys/cmpwrappers/mpif90

6) configure FC=ifort MPI=$MPI_TOP NETCDF_ROOT=$NETCDF_ROOT --enable-mpi --prefix=$CODE
   make

7) executable main_analog is under directory code


--------------------------------------------
COMPILATION STEPS ON YELLOWSTONE: ifort only
--------------------------------------------

Everything is the same as ifort and MPI except

   configure FC=ifort NETCDF_ROOT=$NETCDF_ROOT --prefix=$CODE
   make


-----------------------------------------------------
COMPILATION STEPS ON LINUX CLUSTER: ifort and OpenMPI
-----------------------------------------------------

Right now, the code works with Intel Fortran and OpenMPI. The code
is designed to work in parallel. You must compile with OpenMPI. The configuring
and compiling can be done in "compile_ifort_par.csh" in directory "anen".

1) set paths for the following:

 a) INTEL_PATH
    - top level of Intel compiler, just above bin, e.g.,
      /opt/intel/composer_xe_2013_sp1.3.174

 b) CODE
    - top directory level of code, e.g.,
      $PATH/anen

 c) NETCDF_ROOT
    - top directory level of Netcdf (intel), e.g.,
      /opt/netcdf-20130827-intel14.0.3

 d) HDF
    - top directory level of HDF, e.g.,
      /opt/hdf5-1.8.9-intel14.0.3

 e) NCARG_ROOT_intel
    - top directory level of NCAR graphics (NCL) for intel, e.g.,
      /opt/ncl_ncarg-6.2.0-intel14.0.3

 f) MPI
    - top directory level of OpenMPI (intel), e.g.,
      /opt/openmpi-1.8.1-intel14.0.3

2) execute "compile_ifort_par.csh"
     or
   configure FC=ifort MPI=$MPI_TOP NETCDF_ROOT=$NETCDF_ROOT --enable-openmp --prefix=$CODE
   make

3) executable main_analog is under directory code


----------------------------------------------
COMPILATION STEPS ON LINUX CLUSTER: ifort only
----------------------------------------------

This is the same as ifort with OpenMPI except that MPI path is not needed.

Use "compile_ifort_seq.csh" in directory "anen".

executable main_analog is under directory code


--------------------------------------------------------
COMPILATION STEPS ON LINUX CLUSTER: gfortran and OpenMPI
--------------------------------------------------------

The use of IEEE libraries requires GNU fortran 5.1 or higher.

You need Netcdf and OpenMPI compiled with GNU C and Fortran.

Do the following (paths may be different on your machine)

   setenv CODE $PATH/anen

   setenv NETCDF_ROOT /glade/apps/opt/netcdf/4.3.3.1/gnu/5.1.0

   setenv MPI_TOP /glade/u/home/chengw/gnu/mpich

   configure FC=gfortran MPI=$MPI_TOP NETCDF_ROOT=$NETCDF_ROOT --enable-openmp --prefix=$CODE

   make


-------------------------------------------------
COMPILATION STEPS ON LINUX CLUSTER: gfortran only
-------------------------------------------------

Everything is the same as gfortran and OpenMPI compilation as in the above
but without the MPI environment. Do the following

   configure FC=gfortran NETCDF_ROOT=$NETCDF_ROOT --prefix=$CODE

   make

-------------
Special notes
-------------

- To add new compilation options/flags or to modifying existing ones, you need to modify 
configure.ac . Then,

1) after modifying configure.ac, type "autoreconf"

2) after running "configure", to use MPI, edit file
"configure" and add "$MPI/bin" before each "mpif90"
before typing make

- Options to compile: 

gfortran (must have 5.1 or higher) and Intel Fortran.
Both gfortran and ifort work with OpenMPI or MPI. 
PGI fortran is not working yet. Actually, you need to use pgf95. 
There are many locations where arrays need to be allocated explicitly 
for pgf95  to work. Additionally, the subroutine lib/permute.f90
needs to be modified as follows:

        integer,  intent (in ) :: order(:)

                to

        integer,  intent (in ) :: order(3)

and for lib/permute_4d.f90,

        integer,  intent (in ) :: order(:)
        
                to
        
        integer,  intent (in ) :: order(4)


========================================================
(3) DESCRIPTION OF THE INPUT NAMELIST (analog_input.nml)
========================================================

! Input and output files (with relative path from the "code" directory):
&file_names
pred_file = '../input/"PROJECT NAME"/"INPUT FILE NAME".nc'  ! FORECAST INPUT FILE
obs_file = '../input/"PROJECT NAME"/"INPUT FILE NAME".nc'  ! OBS INPUT FILE (CAN BE THE SAME AS ABOVE)
!out_file = '../output/"PROJECT NAME"/ascii/stn'  ! OUTPUT FILE (ASCII)
out_file = '../output/"PROJECT NAME"/netcdf/"OUTPUT FILE NAME".nc'  ! OUTPUT FILE (NETCDF)
/


! Inputs for observation of variable to be predicted (target variable)
&target_variable
target_var = 'hub_hgt_wind_speed_Obs'  ! TARGET VARIABLE NAME IN INPUT NETCDF FILE
lower_limit_target_var = '0'  ! TARGET VAR LOWER LIMIT
upper_limit_target_var = '101'  ! TARGET VAR UPPER LIMIT
target_var_unit = 'meter per second'  ! UNIT OF TARGET VARIABLE PUT IN THE OUTPUT NETCDF FILE
/

! Inputs for analog predictors
&analog_pred
analog_predictors = 'P_sfc   T  hub_hgt_wind_speed  hub_hgt_wind_dir'  !  PREDICTOR NAMES IN INPUT NETCDF FILE
lower_limits = '700   -40     0                      0'  ! PREDICTOR LOWER LIMITS
upper_limits = '1250  +50    100                    360'  ! PREDICTOR UPPER LIMITS
is_circular = '0      0      0                      1 '  ! PREDICTOR CIRCULARITY FLAG
/

! Analog code input parameters
&anen_parameters
nday_start = -158    ! START DAY FOR ANEN CALCULATIONS; NEGATIVE VALUE MEANS DAYS TO GO BACK,
                     ! -1 FOR LATEST DAY, -2 FOR THE MOST RECENT 2 DAYS, ETC; CANNOT GO BACK PAST 
                     ! SECOND DAY, PLEASE KEEP THIS IN MIND
num_lead_times = 73  ! NUMBER OF LEAD TIMES CONSIDERED FOR ANEN CALCULATIONS
num_analogs = 10     ! NUMBER OF ANALOGS; LAST MEMBER: BEST
hour_start = 0       ! HOURS FROM THE FORECAST INITIALIZATION TIME CORRESPONING TO THE FIRST 
                     ! LEAD TIME IN THE NETCDF FILE
forecast_freq = 1    ! DATA FREQUENCY (1 OR 3 OR 6 HOURS GENERALLY) 
                     ! (FOR SUB-HOURLY, USE FRACTION, FOR EXAMPLE, 0.25 FOR 15 MIN)
point_lead = 2       ! DIMENSION ORDER OF LEAD TIMES AS SEEN IN THE INPUT NETCDF FILE
point_stat = 3       ! DIMENSION ORDER OF STATIONS AS SEEN IN THE INPUT NETCDF FILE
point_days = 1       ! DIMENSION ORDER OF  DAYS AS SEEN IN THE INPUT NETCDF FILE
write_ascii = 0      ! ASCII OUTPUT (1 = TRUE, 0 = FALSE)
write_netcdf = 1     ! NETCDF OUTPUT (1 = TRUE, 0 = FALSE)
find_weights = 0     ! OPTIMAL ANALOG PREDICTORS WEIGHTS COMPUTATION (1 = TRUE, 0 = FALSE); 
                     !THE METRIC IS CALCULATED FROM NDAY_START TO THE LAST DAY IN THE INPUT FILE
opt_metric_endday = 230  ! LAST (DAY) IN THE TIME SERIES TO USE FOR OPTIMIZATION (INTEGER) 
window = 0           ! SEARCH ANALOGS AT THE SAME HOUR AS THE CURRENT FORECAST HOUR, 
                     ! AND +/- window (INTEGER, IN UNITS OF FREQUENCY OF DATA, E.G., HOURLY, 3-HOURLY, ETC.)
trend = 1            ! trend = "t tilde" IN EQ. (2) IN DELLE MONACHE ET AL. 2013, MWR, 41, 3498-3516 
                     ! (INTEGER, IN UNITS OF FREQUENCY OF DATA, E.G., HOURLY, 3-HOURLY, ETC.) 
method = 4           ! 1 = AnEn, ANALOG ENSEMBLE AS IN DELLE MONACHE ET AL. 2013, MWR, 41, 3498-3516
                     ! LAST MEMBER: BEST MEMBER
                     ! 2 = KFAS, KALMAN FILTER ON ANALOG SPACE IDENTIFIED AS "ANKF" 
                     !     IN DELLE MONACHE ET AL. 2011, MWR,  139, 3554-3570
                     ! 3 = KFAN; KF APPLIED TO AnEnMEAN, AS IN DJALALOVA ET AL. 2015, AE, 119, 431-442
                     !     AnEn WILL ALSO BE RUN AND OUTPUT AS WELL
                     ! 4 = AnEnMEAN, WEIGHTED MEAN OF AnEn, IDENTIFIED AS "AN" IN DELLE MONACHE ET AL. 
                     !     2011, MWR,  139, 3554-3570. AnEn WILL ALSO BE RUN AND OUTPUT AS WELL
atec_file_format = 1 ! 0=NOT ATEC FILE FORMAT; 1=ATEC FILE FORMAT
bias_cor = 1         ! 0 = no bias correction for AnEn; 1 = bias correction for AnEn based on relationship between forecast and obs
/

==================================================
(4) CAVEATS
==================================================

The user should be aware of some caveats in running the analog code:

- If you have bad observations, you will not get good results. This is 
  self-evident as past observations are chosen for the analogs. Data quality
  control is crucial before building your input files.

- As of now, the code compiles with Intel (14.0.3 or higher) and 
  GNU compilers (5.1 or higher). Please make sure you use the Netcdf libraries
  compiled with the corresponding compilers.

- When building your input files, please observe the following (C-convention)
  for the order of the dimensions:

  variable(Days, Leadtimes, Staz)
   * Days: day of forecast, e.g., 1, 2, 3, etc, 
   * Leadtimes: forecast lead time (could be hours or minutes)
   * Staz: station number, e.g., 1, 2, 3, etc

  Please set the following in the namelist to observe the required dimensional
  order:

  point_lead = 2       ! DIMENSION ORDER OF LEAD TIMES AS SEEN IN THE INPUT NETCDF FILE
  point_stat = 3       ! DIMENSION ORDER OF STATIONS AS SEEN IN THE INPUT NETCDF FILE
  point_days = 1       ! DIMENSION ORDER OF  DAYS AS SEEN IN THE INPUT NETCDF FILE

  Both sets of the sample input follow the above convention, and it is a good starting
  point to see how the input files are built.

  
